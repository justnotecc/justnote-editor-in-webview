<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>CKEditor 5</title>
  <script src="/core-js/minified.js"></script>
  <script src="/js/ckeditor.js"></script>
  <link rel="stylesheet" href="/css/tailwind.css">
  <link rel="stylesheet" href="/css/ckeditor.css">

  <script>
    const isIPadIPhoneIPod = () => {
      const ua = navigator.userAgent;
      if (/iPad|iPhone|iPod/.test(ua)) {
        return true;
      }
      if (/Mac OS X/.test(ua) && /Safari/.test(ua) && !/Chrome/.test(ua) && !/Firefox/.test(ua)) {
        return true;
      }
      return false;
    };

    const addMaximumScaleToMetaViewport = () => {
      const el = document.querySelector('meta[name=viewport]');
      if (el !== null) {
        let content = el.getAttribute('content');
        const re = /maximum\-scale=[0-9\.]+/g;

        if (re.test(content)) content = content.replace(re, 'maximum-scale=1.0');
        else content = [content, 'maximum-scale=1.0'].join(', ');

        el.setAttribute('content', content);
      }
    };

    if (isIPadIPhoneIPod()) addMaximumScaleToMetaViewport();
  </script>
  <style>
    /* https://www.w3schools.com/howto/howto_css_hide_scrollbars.asp */
    .hide-scrollbar {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }

    .hide-scrollbar::-webkit-scrollbar {
      display: none;   /* Chrome, Safari and Opera */
    }
  </style>
</head>
<body class="antialiased overflow-hidden bg-white">
  <div id="containView" class="w-full">
    <div id="main" class="flex flex-col overflow-hidden">
      <div id="scrollView" class="flex-grow flex-shrink overflow-x-hidden overflow-y-auto">
        <div id="titleView" class="px-1.5 py-1.5 border-b border-gray-200">
          <input type="text" name="titleInput" id="titleInput" class="block w-full border-0 bg-white px-1.5 py-1.5 text-xl font-normal text-gray-800 placeholder:text-gray-500 focus:outline-none focus:ring-0 lg:text-lg" placeholder="Note Title" />
        </div>
        <div id="bodyInput"></div>
        <div id="spaceView"></div>
      </div>
      <div id="bodyToolbar" class="flex-grow-0 flex-shrink-0"></div>
    </div>
    <div id="overView" class="h-px hidden"></div>
  </div>
  <div id="maskView" class="fixed inset-0 bg-transparent hidden"></div>
  <!-- For Tailwind CSS -->
  <!--   <ul><li><label><input type="checkbox" /></label><span></span></li></ul> -->
  <!-- End -->
  <script>
    const throttle = (func, limit) => {
      let lastFunc;
      let lastRan;
      return function () {
        const context = this;
        const args = arguments;
        if (!lastRan) {
          func.apply(context, args);
          lastRan = Date.now();
        } else {
          clearTimeout(lastFunc);
          lastFunc = setTimeout(function () {
            if ((Date.now() - lastRan) >= limit) {
              func.apply(context, args);
              lastRan = Date.now();
            }
          }, limit - (Date.now() - lastRan));
        }
      };
    };

    const debounce = (func, wait, immediate) => {
      let timeout;

      return function () {
        let context = this;
        let args = arguments;

        let later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        let callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);

        if (callNow) func.apply(context, args);
      };
    };

    const setMainHeight = (height, doRepeat = false) => {
      // github.com/react-native-webview/react-native-webview/issues/154
      // Sometimes it fires too early and height is not finalized.
      const containView = document.querySelector('#containView');
      const main = document.querySelector('#main');

      containView.style.height = height + 'px';
      main.style.height = height + 'px';

      if (!doRepeat) return;

      setTimeout(() => {
        containView.style.height = height + 'px';
        main.style.height = height + 'px';
      }, 1);
      setTimeout(() => {
        containView.style.height = height + 'px';
        main.style.height = height + 'px';
      }, 100);
      setTimeout(() => {
        containView.style.height = height + 'px';
        main.style.height = height + 'px';
      }, 250);
    };

    const preventScroll = () => {
      const safeAreaHeight = Math.round(window.visualViewport.height);
      const windowHeight = Math.round(window.innerHeight);

      const containView = document.querySelector('#containView');
      const overView = document.querySelector('#overView');
      if (safeAreaHeight < windowHeight) {
        containView.classList.add(
          'overflow-y-scroll', 'overscroll-contain', 'hide-scrollbar',
        );
        overView.classList.remove('hidden');

        setTimeout(() => {
          if (window.pageYOffset > 0) {
            // scrollTo 0 doesn't work, need scrollBy with big enough number.
            window.scrollBy({ top: windowHeight * -1, behavior: 'smooth' });
          }
        }, 100);
      } else {
        containView.classList.remove(
          'overflow-y-scroll', 'overscroll-contain', 'hide-scrollbar',
        );
        overView.classList.add('hidden');
      }
    };

    const setToolbarGroupedItemsDropdownMaxWidth = () => {
      if (!window.editor) return;

      const editor = window.editor;
      const groupedItemsDropdown = editor.ui.view.toolbar._behavior.groupedItemsDropdown;
      if (!groupedItemsDropdown) return;

      if (window.innerWidth < 389) {
        groupedItemsDropdown.toolbarView.maxWidth = '256px';
      } else if (window.innerWidth < 428) {
        groupedItemsDropdown.toolbarView.maxWidth = '218px';
      } else {
        groupedItemsDropdown.toolbarView.maxWidth = '';
      }
    };

    if (window.visualViewport) {
      setMainHeight(window.visualViewport.height, false);
      window.visualViewport.addEventListener('resize', () => {
        setMainHeight(window.visualViewport.height, true);
      });

      window.visualViewport.addEventListener('resize', throttle(() => {
        setTimeout(preventScroll, 100);
      }, 16));
    } else {
      setMainHeight(window.innerHeight, false);
      window.addEventListener('resize', () => {
        setMainHeight(window.innerHeight, true);
      });
    }
    window.addEventListener('resize', throttle(() => {
      setTimeout(setToolbarGroupedItemsDropdownMaxWidth, 100);
    }, 16));

    const editorConfig = {
      placeholder: 'Start writing...',
      removePlugins: ['Autoformat'],
      fontSize: {
        options: [
          'tiny', 'small', 'default', 'big', 'huge',
          { title: '9', model: '0.5625em' },
          { title: '12', model: '0.75em' },
          { title: '14', model: '0.875em' },
          { title: '18', model: '1.125em' },
          { title: '24', model: '1.5em' },
          { title: '30', model: '1.875em' },
          { title: '36', model: '2.25em' },
          { title: '48', model: '3em' },
          { title: '60', model: '3.75em' },
        ],
      },
      fontColor: {
        colors: [
          { color: 'rgb(31, 41, 55)', label: 'Black' },
          { color: 'rgb(107, 114, 128)', label: 'Gray' },
          { color: 'rgb(185, 28, 28)', label: 'Red' },
          { color: 'rgb(252, 211, 77)', label: 'Yellow' },
          { color: 'rgb(217, 119, 6)', label: 'Orange' },
          { color: 'rgb(120, 53, 15)', label: 'Brown' },
          { color: 'rgb(21, 128, 61)', label: 'Green' },
          { color: 'rgb(29, 78, 216)', label: 'Blue' },
          { color: 'rgb(91, 33, 182)', label: 'Purple' },
          { color: 'rgb(219, 39, 119)', label: 'Pink' },
          { color: 'rgb(229, 231, 235)', label: 'Light gray' },
          { color: 'rgb(255, 255, 255)', label: 'White', hasBorder: true },
        ],
        columns: 6,
        documentColors: 0,
      },
      fontBackgroundColor: {
        colors: [
          { color: 'rgb(31, 41, 55)', label: 'Black' },
          { color: 'rgb(107, 114, 128)', label: 'Gray' },
          { color: 'rgb(239, 68, 68)', label: 'Red' },
          { color: 'rgb(252, 211, 77)', label: 'Yellow' },
          { color: 'rgb(245, 158, 11)', label: 'Orange' },
          { color: 'rgb(180, 83, 9)', label: 'Brown' },
          { color: 'rgb(74, 222, 128)', label: 'Green' },
          { color: 'rgb(147, 197, 253)', label: 'Blue' },
          { color: 'rgb(196, 181, 253)', label: 'Purple' },
          { color: 'rgb(251, 207, 232)', label: 'Pink' },
          { color: 'rgb(229, 231, 235)', label: 'Light gray' },
          { color: 'rgb(255, 255, 255)', label: 'White', hasBorder: true },
        ],
        columns: 6,
        documentColors: 0,
      },
    };

    DecoupledEditor.create(document.querySelector('#bodyInput'), editorConfig)
      .then(editor => {
        const bodyToolbar = document.querySelector('#bodyToolbar');
        bodyToolbar.appendChild(editor.ui.view.toolbar.element);

        const groupedItemsDropdown = editor.ui.view.toolbar._behavior.groupedItemsDropdown;
        if (groupedItemsDropdown) groupedItemsDropdown.panelPosition = 'nw';

        const toolbarItems = editor.ui.view.toolbar.items;
        toolbarItems.get(2).panelPosition = 'nme';
        toolbarItems.get(3).panelPosition = 'nme';
        toolbarItems.get(4).panelPosition = 'nmw';
        toolbarItems.get(5).panelPosition = 'nmw';
        toolbarItems.get(10).on('done', () => {
          if (groupedItemsDropdown) groupedItemsDropdown.set('isOpen', false);
          if (window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage('focus:webView:true');
          }
        });

        if (window.ReactNativeWebView) {
          const SEP = '_jUSTnOTE-sEpArAtOr_';

          const onFocusChange = () => {
            setTimeout(() => {
              const titleInput = document.querySelector('#titleInput');
              const isTitleFocused = titleInput === document.activeElement;
              const isBodyFocused = editor.editing.view.document.isFocused;

              if (isTitleFocused || isBodyFocused) {
                window.ReactNativeWebView.postMessage('focus:webView:true');
              }
            }, 1);
          };
          document.querySelector('#titleInput').addEventListener('focus', onFocusChange);
          editor.editing.view.document.on('change:isFocused', onFocusChange);

          const setThemeMode = (mode) => {
            const body = document.querySelector('body');
            if (mode === 1) body.classList.add('blk:bg-gray-900');
            else body.classList.remove('blk:bg-gray-900');

            const main = document.querySelector('#main');
            if (mode === 0) main.classList.add('wht-mode');
            else main.classList.remove('wht-mode');

            if (mode === 1) main.classList.add('blk-mode');
            else main.classList.remove('blk-mode');

            const titleView = document.querySelector('#titleView');
            if (mode === 1) titleView.classList.add('blk:border-gray-700');
            else titleView.classList.remove('blk:border-gray-700');

            const titleInput = document.querySelector('#titleInput');
            if (mode === 1) {
              titleInput.classList.add(
                'blk:bg-gray-900', 'blk:text-gray-200', 'blk:placeholder:text-gray-400'
              );
            } else {
              titleInput.classList.remove(
                'blk:bg-gray-900', 'blk:text-gray-200', 'blk:placeholder:text-gray-400'
              );
            }
          };
          // semi-collon to end a function is important for export-ckeditor-as-string.js

          const setEditorFontSizes = (doMoreEditorFontSizes) => {
            const main = document.querySelector('#main');
            if (doMoreEditorFontSizes) {
              main.classList.add('more-font-sizes');
              main.classList.remove('default-font-sizes');
            } else {
              main.classList.add('default-font-sizes');
              main.classList.remove('more-font-sizes');
            }

            const spaceView = document.querySelector('#spaceView');
            if (doMoreEditorFontSizes) {
              spaceView.classList.add('h-32');
              spaceView.classList.remove('h-28');
            } else {
              spaceView.classList.add('h-28');
              spaceView.classList.remove('h-32');
            }
          };

          const setEditable = (editable) => {
            const maskView = document.querySelector('#maskView');
            maskView.style.display = editable ? 'none' : 'block';
          };

          const setScrollEnabled = (enabled) => {
            const scrollView = document.querySelector('#scrollView');
            scrollView.style.overflowY = enabled ? null : 'hidden';
          };

          const scrollTo = (x, y) => {
            const scrollView = document.querySelector('#scrollView');
            scrollView.scrollTo(x, y);
          };

          const setTitle = (title) => {
            document.querySelector('#titleInput').value = title;
          };

          let dir;

          const setDir = (_dir) => {
            dir = _dir
          };

          const revokeObjectUrl = (objectUrl) => {
            URL.revokeObjectURL(objectUrl);
          };

          let noteMedia = [];
          let objectUrlContents = {};
          let objectUrlNames = {};

          const clearNoteMedia = () => {
            noteMedia = [];

            for (const objectUrl in objectUrlContents) {
              URL.revokeObjectURL(objectUrl);
            }
            objectUrlContents = {};

            objectUrlNames = {};
          };

          const addNoteMedia = (name, content) => {
            noteMedia.push({ name, content });
          };

          const isString = (val) => {
            return typeof val === 'string' || val instanceof String;
          };

          const dataUrlToBlob = async (content) => {
            const res = await fetch(content);
            const blob = await res.blob();
            return blob;
          };

          const replaceWithContents = async (body) => {
            const _media = noteMedia.filter(({ content }) => {
              return isString(content) && content.startsWith('data:');
            });
            const media = await Promise.all(_media.map(async ({ name, content }) => {
              const blob = await dataUrlToBlob(content);
              return { name, content, blob };
            }));

            for (const { name, content, blob } of media) {
              const objectUrl = URL.createObjectURL(blob);

              objectUrlContents[objectUrl] = { fname: name, content };
              objectUrlNames[objectUrl] = name;

              body = body.replaceAll(name, objectUrl);
            }

            return body;
          };

          const replaceWithFiles = (body) => {
            const media = noteMedia.filter(({ name }) => {
              return isString(name) && name.startsWith('cdroot/');
            });
            for (const { name, content } of media) {
              const fileUrl = name.replace('cdroot/', 'file://' + dir + '/');

              window.ReactNativeWebView.postMessage(
                'include:objectUrlFiles:' + fileUrl + SEP + name + SEP + content
              );
              objectUrlNames[fileUrl] = name;

              body = body.replaceAll(name, fileUrl);
            }

            return body;
          };

          const setBody = async (body) => {
            body = await replaceWithContents(body);
            body = replaceWithFiles(body);
            editor.setData(body);
          };

          const getData = () => {
            window.ReactNativeWebView.postMessage('clear:objectUrlContents:true');
            for (const [k, v] of Object.entries(objectUrlContents)) {
              window.ReactNativeWebView.postMessage(
                'add:objectUrlContents:' + k + SEP + v.fname + SEP + v.content
              );
            }

            window.ReactNativeWebView.postMessage('clear:objectUrlNames:true');
            for (const [k, v] of Object.entries(objectUrlNames)) {
              window.ReactNativeWebView.postMessage(
                'add:objectUrlNames:' + k + SEP + v
              );
            }

            const title = document.querySelector('#titleInput').value;
            const body = editor.getData();
            window.ReactNativeWebView.postMessage('data:webView:' + title + SEP + body);
          };

          // Need debounce for now to prevent calling editor.getData too often
          // There is still performance issue about that.
          // https://github.com/ckeditor/ckeditor5/issues/5812
          const onDataChange = debounce(() => {
            window.ReactNativeWebView.postMessage('clear:editingObjectUrlContents:true');
            for (const [k, v] of Object.entries(objectUrlContents)) {
              window.ReactNativeWebView.postMessage(
                'add:editingObjectUrlContents:' + k + SEP + v.fname + SEP + v.content
              );
            }

            window.ReactNativeWebView.postMessage('clear:editingObjectUrlNames:true');
            for (const [k, v] of Object.entries(objectUrlNames)) {
              window.ReactNativeWebView.postMessage(
                'add:editingObjectUrlNames:' + k + SEP + v
              );
            }

            const title = document.querySelector('#titleInput').value;
            const body = editor.getData();
            window.ReactNativeWebView.postMessage(
              'editingData:webView:' + title + SEP + body
            );
          }, 1000);
          document.querySelector('#titleInput').addEventListener('input', onDataChange);
          editor.model.document.on('change:data', onDataChange);

          window.justnote = {
            setThemeMode, setEditorFontSizes, setEditable, setScrollEnabled, scrollTo,
            setTitle, setDir, revokeObjectUrl, clearNoteMedia, addNoteMedia, setBody,
            getData,
          };
          window.ReactNativeWebView.postMessage('editor:isReady:true');
        }

        window.editor = editor;
        setToolbarGroupedItemsDropdownMaxWidth();
      })
      .catch( error => {
        console.error('There was a problem initializing the editor.', error);
      });
  </script>
</body>
</html>
