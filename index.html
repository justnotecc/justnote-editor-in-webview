<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>CKEditor 5</title>
  <script src="/core-js/minified.js"></script>
  <script src="/js/ckeditor.js"></script>
  <link rel="stylesheet" href="/css/tailwind.css">
  <link rel="stylesheet" href="/css/ckeditor.css">
</head>
<body class="antialiased overflow-hidden">
  <div id="main" class="flex flex-col overflow-hidden">
    <div class="flex-grow flex-shrink overflow-x-hidden overflow-y-auto">
      <div class="px-1.5 py-1.5 border-b border-gray-200">
        <input type="text" name="titleInput" id="titleInput" class="block w-full text-xl font-normal text-gray-800 px-1.5 py-1.5 placeholder-gray-500 border-0 focus:outline-none focus:ring-0 lg:text-lg" placeholder="Note Title" />
      </div>
      <div id="bodyInput"></div>
      <div class="h-28"></div>
    </div>
    <div id="bodyToolbar" class="flex-grow-0 flex-shrink-0"></div>
  </div>

  <script>
    const main = document.querySelector('#main');
    window.addEventListener('resize', () => {
      // github.com/react-native-webview/react-native-webview/issues/154
      // Sometimes it fires too early and height is not finalized.
      main.style.height = window.innerHeight + 'px';
      setTimeout(() => {
        main.style.height = window.innerHeight + 'px';
      }, 1);
      setTimeout(() => {
        main.style.height = window.innerHeight + 'px';
      }, 100);
      setTimeout(() => {
        main.style.height = window.innerHeight + 'px';
      }, 250);
    });
    main.style.height = window.innerHeight + 'px';

    const editorConfig = {
      placeholder: 'Start writing...',
      removePlugins: ['Autoformat'],
      fontColor: {
        colors: [
          { color: 'rgb(31, 41, 55)', label: 'Black' },
          { color: 'rgb(107, 114, 128)', label: 'Gray' },
          { color: 'rgb(185, 28, 28)', label: 'Red' },
          { color: 'rgb(252, 211, 77)', label: 'Yellow' },
          { color: 'rgb(217, 119, 6)', label: 'Orange' },
          { color: 'rgb(120, 53, 15)', label: 'Brown' },
          { color: 'rgb(21, 128, 61)', label: 'Green' },
          { color: 'rgb(29, 78, 216)', label: 'Blue' },
          { color: 'rgb(91, 33, 182)', label: 'Purple' },
          { color: 'rgb(219, 39, 119)', label: 'Pink' },
          { color: 'rgb(229, 231, 235)', label: 'Light gray' },
          { color: 'rgb(255, 255, 255)', label: 'White', hasBorder: true },
        ],
        columns: 6,
        documentColors: 0,
      },
      fontBackgroundColor: {
        colors: [
          { color: 'rgb(31, 41, 55)', label: 'Black' },
          { color: 'rgb(107, 114, 128)', label: 'Gray' },
          { color: 'rgb(239, 68, 68)', label: 'Red' },
          { color: 'rgb(252, 211, 77)', label: 'Yellow' },
          { color: 'rgb(245, 158, 11)', label: 'Orange' },
          { color: 'rgb(180, 83, 9)', label: 'Brown' },
          { color: 'rgb(74, 222, 128)', label: 'Green' },
          { color: 'rgb(147, 197, 253)', label: 'Blue' },
          { color: 'rgb(196, 181, 253)', label: 'Purple' },
          { color: 'rgb(251, 207, 232)', label: 'Pink' },
          { color: 'rgb(229, 231, 235)', label: 'Light gray' },
          { color: 'rgb(255, 255, 255)', label: 'White', hasBorder: true },
        ],
        columns: 6,
        documentColors: 0,
      },
    };

    DecoupledEditor.create(document.querySelector('#bodyInput'), editorConfig)
      .then(editor => {
        const bodyToolbar = document.querySelector('#bodyToolbar');
        bodyToolbar.appendChild(editor.ui.view.toolbar.element);

        const groupedItemsDropdown = editor.ui.view.toolbar._behavior.groupedItemsDropdown;
        if (groupedItemsDropdown) groupedItemsDropdown.panelPosition = 'nw';

        const toolbarItems = editor.ui.view.toolbar.items;
        toolbarItems.get(3).panelPosition = 'nme';
        toolbarItems.get(4).panelPosition = 'nme';
        toolbarItems.get(5).panelPosition = 'nmw';
        toolbarItems.get(8).on('done', () => {
          if (groupedItemsDropdown) groupedItemsDropdown.set('isOpen', false);
        });

        if (window.ReactNativeWebView) {
          const onFocusChange = () => {
            setTimeout(() => {
              const titleInput = document.querySelector('#titleInput');
              const isTitleFocused = titleInput === document.activeElement;
              const isBodyFocused = editor.editing.view.document.isFocused;

              if (isTitleFocused || isBodyFocused) {
                window.ReactNativeWebView.postMessage('focus:webView:true');
              }
            }, 1);
          };
          document.querySelector('#titleInput').addEventListener('focus', onFocusChange);
          editor.editing.view.document.on('change:isFocused', onFocusChange);

          const setTitle = (title) => {
            document.querySelector('#titleInput').value = title;
          };

          let noteMedia = [];
          let objectUrlNames = {};

          const clearNoteMedia = () => {
            noteMedia = [];

            if (window.CKEditorObjectUrlContents) {
              for (const objectUrl in window.CKEditorObjectUrlContents) {
                URL.revokeObjectURL(objectUrl);
              }
            }
            window.CKEditorObjectUrlContents = {};
            objectUrlNames = {};
          };

          const addNoteMedia = (name, content) => {
            noteMedia.push({ name, content });
          };

          const isString = (val) => {
            return typeof val === 'string' || val instanceof String;
          };

          const dataUrlToBlob = async (content) => {
            const res = await fetch(content);
            const blob = await res.blob();
            return blob;
          };

          const setBody = async (body) => {
            const _media = noteMedia.filter(({ content }) => {
              return isString(content) && content.startsWith('data:');
            });
            const media = await Promise.all(_media.map(async ({ name, content }) => {
              const blob = await dataUrlToBlob(content);
              return { name, content, blob };
            }));

            for (const { name, content, blob } of media) {
              const objectUrl = URL.createObjectURL(blob);

              window.CKEditorObjectUrlContents[objectUrl] = { fname: name, content };
              objectUrlNames[objectUrl] = name;

              body = body.replaceAll(name, objectUrl);
            }

            editor.setData(body);
          };

          const getData = () => {
            const SEP = '_jUSTnOTE-sEpArAtOr_';

            window.ReactNativeWebView.postMessage('clear:objectUrlContents:true');
            if (window.CKEditorObjectUrlContents) {
              for (const [k, v] of Object.entries(window.CKEditorObjectUrlContents)) {
                window.ReactNativeWebView.postMessage(
                  'add:objectUrlContents:' + k + SEP + v.fname + SEP + v.content
                );
              }
            }

            window.ReactNativeWebView.postMessage('clear:objectUrlNames:true');
            for (const [k, v] of Object.entries(objectUrlNames)) {
              window.ReactNativeWebView.postMessage(
                'add:objectUrlNames:' + k + SEP + v
              );
            }

            const title = document.querySelector('#titleInput').value;
            const body = editor.getData();
            window.ReactNativeWebView.postMessage('data:webView:' + title + SEP + body);
          };

          window.justnote = { setTitle, clearNoteMedia, addNoteMedia, setBody, getData };
          window.ReactNativeWebView.postMessage('editor:isReady:true');
        }

        window.editor = editor;
      })
      .catch( error => {
        console.error('There was a problem initializing the editor.', error);
      });
  </script>
</body>
</html>
